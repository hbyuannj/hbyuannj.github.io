<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>老实人与骗子逻辑推理</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        honest: '#10B981',      // 老实人-绿色
                        liar: '#EF4444',        // 骗子-红色
                        neutral: '#6B7280',     // 待定-灰色
                        background: '#F9FAFB'   // 背景色
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .person-card {
                @apply relative rounded-lg p-4 cursor-pointer transition-all duration-300 border-2;
            }
            .person-neutral {
                @apply border-neutral bg-white hover:bg-gray-50;
            }
            .person-honest {
                @apply border-honest bg-green-50;
            }
            .person-liar {
                @apply border-liar bg-red-50;
            }
            .related-highlight {
                @apply ring-2 ring-blue-400 shadow-md;
            }
            .conflict-highlight {
                @apply ring-2 ring-red-500 shadow-md;
            }
            .fade-in {
                animation: fadeIn 0.5s ease-in-out;
            }
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            .tip-highlight {
                @apply font-medium;
            }
            .confirm-btn {
                @apply absolute bottom-3 right-3 px-2 py-1 text-xs rounded transition-colors;
            }
            .confirm-btn-enabled {
                @apply bg-blue-600 text-white hover:bg-blue-700 cursor-pointer;
            }
            .confirm-btn-disabled {
                @apply bg-gray-300 text-gray-500 cursor-not-allowed;
            }
        }
    </style>
</head>
<body class="bg-background min-h-screen p-4 md:p-8 max-w-5xl mx-auto">
    <!-- 标题区域 -->
    <header class="text-center mb-8">
        <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-gray-800 mb-2">老实人与骗子逻辑推理</h1>
        <p class="text-gray-600">通过逻辑推理判断谁是老实人（永远说真话），谁是骗子（永远说假话）</p>
    </header>

    <!-- 题干区域 -->
    <div class="bg-white rounded-lg p-6 shadow-sm mb-6 fade-in">
        <h2 class="text-xl font-semibold text-gray-800 mb-4">问题描述</h2>
        <p class="text-gray-700 mb-4">在甲、乙、丙、丁、戊五个人中，有2个老实人（永远说真话）和3个骗子（永远说假话）。他们分别说了以下几句话，请判断每个人的身份。</p>
        
        <ul class="space-y-2 text-gray-700 ml-2">
            <li><span class="font-medium">甲：</span>乙是骗子。</li>
            <li><span class="font-medium">乙：</span>丙是骗子。</li>
            <li><span class="font-medium">丙：</span>戊是骗子。</li>
            <li><span class="font-medium">丁：</span>甲和乙都是骗子。</li>
            <li><span class="font-medium">戊：</span>甲和丁都是老实人。</li>
        </ul>
    </div>

    <!-- 计数器和操作区 -->
    <div class="bg-white rounded-lg p-5 shadow-sm mb-6 fade-in">
        <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center space-x-6">
                <div>
                    <span class="text-honest font-medium">老实人：</span>
                    <span id="honestCount" class="text-xl font-bold">0</span>
                </div>
                <div>
                    <span class="text-liar font-medium">骗子：</span>
                    <span id="liarCount" class="text-xl font-bold">0</span>
                </div>
                <div>
                    <span class="text-neutral font-medium">待定：</span>
                    <span id="neutralCount" class="text-xl font-bold">5</span>
                </div>
                <div>
                    <span class="text-blue-600 font-medium">已确认：</span>
                    <span id="confirmedCount" class="text-xl font-bold">0</span>
                </div>
            </div>
            
            <div class="flex space-x-3">
                <button id="checkBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-md disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors" disabled>
                    <i class="fa fa-check mr-1"></i> 检查结果
                </button>
                <button id="resetBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-5 py-2 rounded-md transition-colors">
                    <i class="fa fa-refresh mr-1"></i> 重置
                </button>
            </div>
        </div>
        
        <!-- 智能辅助推理开关 -->
        <div class="flex items-center mt-3">
            <input type="checkbox" id="smartAssist" class="mr-2 h-4 w-4 text-green-600 rounded">
            <label for="smartAssist" class="text-gray-700">启用智能辅助推理</label>
        </div>
    </div>

    <!-- 自动推理提示区域（常驻显示） -->
    <div id="inferenceTips" class="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6 min-h-[100px] rounded-r-lg fade-in">
        <h3 class="font-bold text-blue-700 mb-2 flex items-center">
            <i class="fa fa-lightbulb-o mr-2"></i>自动推理提示
        </h3>
        <div id="tipsContent" class="text-blue-600 text-sm space-y-1 max-h-[300px] overflow-y-auto pr-2">
            开启智能辅助推理后，设定人物角色并点击"确定"按钮，将自动进行单步推理或矛盾检测
        </div>
    </div>

    <!-- 人物展示区 -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
        <div id="person-a" class="person-card person-neutral fade-in" onclick="togglePersonStatus('a')">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold text-gray-800">甲</h3>
                <span class="status-badge px-2 py-1 rounded text-xs font-medium bg-neutral/20 text-neutral">待定</span>
            </div>
            <p class="mt-2 text-gray-700">陈述：乙是骗子。</p>
            <button class="confirm-btn confirm-btn-disabled" onclick="confirmPersonStatus('a', event)">确定</button>
        </div>
        
        <div id="person-b" class="person-card person-neutral fade-in" onclick="togglePersonStatus('b')">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold text-gray-800">乙</h3>
                <span class="status-badge px-2 py-1 rounded text-xs font-medium bg-neutral/20 text-neutral">待定</span>
            </div>
            <p class="mt-2 text-gray-700">陈述：丙是骗子。</p>
            <button class="confirm-btn confirm-btn-disabled" onclick="confirmPersonStatus('b', event)">确定</button>
        </div>
        
        <div id="person-c" class="person-card person-neutral fade-in" onclick="togglePersonStatus('c')">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold text-gray-800">丙</h3>
                <span class="status-badge px-2 py-1 rounded text-xs font-medium bg-neutral/20 text-neutral">待定</span>
            </div>
            <p class="mt-2 text-gray-700">陈述：戊是骗子。</p>
            <button class="confirm-btn confirm-btn-disabled" onclick="confirmPersonStatus('c', event)">确定</button>
        </div>
        
        <div id="person-d" class="person-card person-neutral fade-in" onclick="togglePersonStatus('d')">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold text-gray-800">丁</h3>
                <span class="status-badge px-2 py-1 rounded text-xs font-medium bg-neutral/20 text-neutral">待定</span>
            </div>
            <p class="mt-2 text-gray-700">陈述：甲和乙都是骗子。</p>
            <button class="confirm-btn confirm-btn-disabled" onclick="confirmPersonStatus('d', event)">确定</button>
        </div>
        
        <div id="person-e" class="person-card person-neutral fade-in md:col-span-2" onclick="togglePersonStatus('e')">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold text-gray-800">戊</h3>
                <span class="status-badge px-2 py-1 rounded text-xs font-medium bg-neutral/20 text-neutral">待定</span>
            </div>
            <p class="mt-2 text-gray-700">陈述：甲和丁都是老实人。</p>
            <button class="confirm-btn confirm-btn-disabled" onclick="confirmPersonStatus('e', event)">确定</button>
        </div>
    </div>

    <!-- 结果区域 -->
    <div id="resultArea" class="hidden bg-white rounded-lg p-5 shadow-sm mb-8 fade-in">
        <h2 id="resultTitle" class="text-xl font-semibold mb-3"></h2>
        <div id="resultContent" class="text-gray-700"></div>
    </div>

    <!-- 规律总结区域 -->
    <div class="bg-white rounded-lg p-5 shadow-sm mb-8 fade-in">
        <h2 class="text-xl font-semibold text-gray-800 mb-4">解题规律总结</h2>
        <ul class="space-y-2 text-gray-700 list-disc ml-5">
            <li>老实人永远说真话，骗子永远说假话</li>
            <li>可通过假设法：先假设某人是老实人/骗子，再验证是否符合逻辑</li>
            <li>注意数量约束：恰好有2个老实人和3个骗子</li>
            <li>寻找矛盾点：如果某人的陈述与已知事实矛盾，则假设不成立</li>
            <li>利用关联关系：一个人的陈述往往涉及其他人，可顺藤摸瓜推理</li>
        </ul>
    </div>

    <script>
        // 人物数据模型
        const persons = [
            { 
                id: 'a', 
                name: '甲', 
                statement: '乙是骗子。', 
                status: 'neutral',  // neutral, honest, liar
                isConfirmed: false, // 是否已确认角色
                refersTo: ['b'],    // 陈述中提到的人
                referredBy: ['d', 'e']  // 提到自己的人
            },
            { 
                id: 'b', 
                name: '乙', 
                statement: '丙是骗子。', 
                status: 'neutral',
                isConfirmed: false,
                refersTo: ['c'],
                referredBy: ['a', 'd']  // 丁也提到乙
            },
            { 
                id: 'c', 
                name: '丙', 
                statement: '戊是骗子。', 
                status: 'neutral',
                isConfirmed: false,
                refersTo: ['e'],
                referredBy: ['b']
            },
            { 
                id: 'd', 
                name: '丁', 
                statement: '甲和乙都是骗子。', 
                status: 'neutral',
                isConfirmed: false,
                refersTo: ['a', 'b'],
                referredBy: ['e']  // 戊提到丁
            },
            { 
                id: 'e', 
                name: '戊', 
                statement: '甲和丁都是老实人。',
                status: 'neutral',
                isConfirmed: false,
                refersTo: ['a', 'd'],
                referredBy: ['c']
            }
        ];

        // 智能辅助推理开关状态
        let isSmartAssistEnabled = false;
        // 记录提示信息（避免重复提示）
        let tipHistory = [];

        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化人物显示
            persons.forEach(person => {
                renderPerson(person);
                updateConfirmButton(person.id);
            });
            updateCounter();
            
            // 绑定智能辅助开关事件
            document.getElementById('smartAssist').addEventListener('change', (e) => {
                isSmartAssistEnabled = e.target.checked;
                updateTips(`智能辅助推理已${isSmartAssistEnabled ? '开启' : '关闭'}`, 'info');
            });
            
            // 绑定重置按钮事件
            document.getElementById('resetBtn').addEventListener('click', resetAll);
            
            // 绑定检查结果按钮事件
            document.getElementById('checkBtn').addEventListener('click', checkResult);
        });

        /**
         * 切换人物状态（中性→老实人→骗子→中性）
         */
        function togglePersonStatus(personId) {
            const person = persons.find(p => p.id === personId);
            if (!person || person.isConfirmed) return; // 已确认的角色不能再修改
            
            // 切换状态
            const statusOrder = ['neutral', 'honest', 'liar'];
            const currentIndex = statusOrder.indexOf(person.status);
            person.status = statusOrder[(currentIndex + 1) % 3];
            
            // 更新UI
            renderPerson(person);
            updateConfirmButton(personId);
            updateCounter();
            highlightRelatedPersons(personId);
            
            // 检查是否可以启用"检查结果"按钮
            checkButtonAvailability();
        }

        /**
         * 确认人物角色（点击确定按钮后触发）
         */
        function confirmPersonStatus(personId, event) {
            // 阻止事件冒泡，避免触发卡片点击
            event.stopPropagation();
            
            const person = persons.find(p => p.id === personId);
            if (!person || person.isConfirmed || person.status === 'neutral') return;
            
            // 标记为已确认
            person.isConfirmed = true;
            updateConfirmButton(personId);
            updateCounter();
            updateTips(`${person.name}的角色已确认为${person.status === 'honest' ? '老实人' : '骗子'}`, 'info');
            
            // 触发智能辅助推理（仅一步）
            if (isSmartAssistEnabled) {
                handleSmartInference(person);
            }
            
            // 检查是否所有人物都已确认且没有中性状态
            const allConfirmed = persons.every(p => p.isConfirmed);
            const hasNeutral = persons.some(p => p.status === 'neutral');
            
            // 如果全部确认完成，自动触发检查结果
            if (allConfirmed && !hasNeutral) {
                updateTips("所有角色已确认，自动检查结果...", 'info');
                // 延迟一点执行，让用户看到最后一个确认的反馈
                setTimeout(checkResult, 500);
            } else {
                // 否则只更新按钮状态
                checkButtonAvailability();
            }
        }

        /**
         * 更新确认按钮状态
         */
        function updateConfirmButton(personId) {
            const person = persons.find(p => p.id === personId);
            const btn = document.querySelector(`#person-${personId} .confirm-btn`);
            
            if (person.isConfirmed) {
                btn.className = 'confirm-btn confirm-btn-disabled';
                btn.textContent = '已确认';
            } else if (person.status === 'neutral') {
                btn.className = 'confirm-btn confirm-btn-disabled';
                btn.textContent = '确定';
            } else {
                btn.className = 'confirm-btn confirm-btn-enabled';
                btn.textContent = '确定';
            }
        }

        /**
         * 渲染人物卡片
         */
        function renderPerson(person) {
            const card = document.getElementById(`person-${person.id}`);
            const badge = card.querySelector('.status-badge');
            
            // 移除所有状态类
            card.classList.remove('person-neutral', 'person-honest', 'person-liar');
            badge.classList.remove('bg-neutral/20', 'text-neutral', 
                                 'bg-honest/20', 'text-honest', 
                                 'bg-liar/20', 'text-liar');
            
            // 添加当前状态类
            switch(person.status) {
                case 'honest':
                    card.classList.add('person-honest');
                    badge.classList.add('bg-honest/20', 'text-honest');
                    badge.textContent = '老实人';
                    break;
                case 'liar':
                    card.classList.add('person-liar');
                    badge.classList.add('bg-liar/20', 'text-liar');
                    badge.textContent = '骗子';
                    break;
                default:
                    card.classList.add('person-neutral');
                    badge.classList.add('bg-neutral/20', 'text-neutral');
                    badge.textContent = '待定';
            }
            
            // 已确认的卡片添加特殊样式
            if (person.isConfirmed) {
                card.classList.add('opacity-90');
                card.classList.add('ring-1', 'ring-blue-300');
            } else {
                card.classList.remove('opacity-90', 'ring-1', 'ring-blue-300');
            }
        }

        /**
         * 更新计数器
         */
        function updateCounter() {
            const honestCount = persons.filter(p => p.status === 'honest').length;
            const liarCount = persons.filter(p => p.status === 'liar').length;
            const neutralCount = persons.filter(p => p.status === 'neutral').length;
            const confirmedCount = persons.filter(p => p.isConfirmed).length;
            
            document.getElementById('honestCount').textContent = honestCount;
            document.getElementById('liarCount').textContent = liarCount;
            document.getElementById('neutralCount').textContent = neutralCount;
            document.getElementById('confirmedCount').textContent = confirmedCount;
        }

        /**
         * 高亮相关人物
         */
        function highlightRelatedPersons(personId) {
            // 先清除所有高亮
            persons.forEach(p => {
                const card = document.getElementById(`person-${p.id}`);
                card.classList.remove('related-highlight', 'conflict-highlight');
            });
            
            // 获取当前人物
            const person = persons.find(p => p.id === personId);
            if (!person || person.status === 'neutral') return;
            
            // 高亮当前人物提到的人和提到当前人物的人
            [...person.refersTo, ...person.referredBy].forEach(id => {
                const card = document.getElementById(`person-${id}`);
                if (card) card.classList.add('related-highlight');
            });
        }

        /**
         * 高亮冲突人物
         */
        function highlightConflicts(personIds) {
            // 先清除所有冲突高亮
            document.querySelectorAll('.person-card').forEach(card => {
                card.classList.remove('conflict-highlight');
            });
            
            // 为冲突人物添加高亮
            personIds.forEach(id => {
                const card = document.getElementById(`person-${id}`);
                if (card) {
                    card.classList.add('conflict-highlight');
                    // 添加闪烁动画
                    card.classList.add('animate-pulse');
                    setTimeout(() => card.classList.remove('animate-pulse'), 2000);
                }
            });
        }

        /**
         * 检查按钮是否可用
         */
        function checkButtonAvailability() {
            // 所有人物都已确认且没有中性状态时才启用检查按钮
            const allConfirmed = persons.every(p => p.isConfirmed);
            const hasNeutral = persons.some(p => p.status === 'neutral');
            document.getElementById('checkBtn').disabled = !allConfirmed || hasNeutral;
        }

        /**
         * 重置所有设置
         */
        function resetAll() {
            // 重置人物状态
            persons.forEach(person => {
                person.status = 'neutral';
                person.isConfirmed = false;
                renderPerson(person);
                updateConfirmButton(person.id);
            });
            
            // 重置计数器
            updateCounter();
            
            // 清除高亮
            document.querySelectorAll('.person-card').forEach(card => {
                card.classList.remove('related-highlight', 'conflict-highlight', 'animate-pulse');
            });
            
            // 隐藏结果区域
            document.getElementById('resultArea').classList.add('hidden');
            
            // 重置提示区域
            document.getElementById('tipsContent').innerHTML = 
                '开启智能辅助推理后，设定人物角色并点击"确定"按钮，将自动进行单步推理或矛盾检测';
            tipHistory = [];
            
            // 禁用检查按钮
            document.getElementById('checkBtn').disabled = true;
        }

        /**
         * 更新自动推理提示区域
         */
        function updateTips(message, type = 'info') {
            const tipsContent = document.getElementById('tipsContent');
            const timestamp = new Date().toLocaleTimeString();
            
            // 避免重复提示
            if (tipHistory.includes(message)) return;
            tipHistory.push(message);
            
            // 初始提示特殊处理
            if (tipsContent.innerHTML.includes('开启智能辅助推理后，设定人物角色并点击"确定"按钮，将自动进行单步推理或矛盾检测')) {
                tipsContent.innerHTML = '';
            }
            
            // 根据类型添加样式
            let styleClass = 'text-blue-600';
            if (type === 'conflict') styleClass = 'text-red-600 tip-highlight';
            if (type === 'inference') styleClass = 'text-green-600 tip-highlight';
            
            // 追加新提示
            tipsContent.innerHTML += `
                <div class="flex items-start">
                    <span class="text-gray-400 text-xs mr-2 mt-0.5">${timestamp}</span>
                    <span class="${styleClass}">${message}</span>
                </div>
            `;
            
            // 自动滚动到底部
            tipsContent.scrollTop = tipsContent.scrollHeight;
        }

        /**
         * 智能辅助推理核心逻辑（单步推理+矛盾检测）
         */
        function handleSmartInference(updatedPerson) {
            // 只有已确认且非中性的角色才触发推理
            if (updatedPerson.status === 'neutral' || !updatedPerson.isConfirmed) return;
            
            const { id: currentId, name: currentName, status: currentStatus, refersTo, statement } = updatedPerson;
            
            // 遍历当前人物陈述中涉及的所有相关人物
            refersTo.forEach(targetId => {
                const targetPerson = persons.find(p => p.id === targetId);
                const targetName = targetPerson.name;
                
                // 如果目标人物已确认，则只做矛盾检测
                if (targetPerson.isConfirmed) {
                    checkForConflicts(currentId, currentName, currentStatus, statement, targetPerson);
                    return;
                }
                
                // 1. 推理逻辑：根据当前人物角色推导相关人物应有的角色
                let expectedStatus;
                if (currentStatus === 'honest') {
                    // 老实人说真话：陈述内容即为事实
                    expectedStatus = statement.includes('骗子') ? 'liar' : 'honest';
                } else {
                    // 骗子说假话：陈述内容的相反即为事实
                    expectedStatus = statement.includes('骗子') ? 'honest' : 'liar';
                }
                
                // 特殊处理丁和戊的复合陈述
                if (currentId === 'd' && currentStatus === 'honest') {
                    // 丁是老实人：甲和乙都是骗子
                    handleCompoundStatement('d', ['a', 'b'], 'liar');
                }
                if (currentId === 'd' && currentStatus === 'liar') {
                    // 丁是骗子：并非甲和乙都是骗子（至少有一个是老实人）
                    updateTips(`自动推理：丁是骗子，故甲和乙不可能都是骗子（至少有一个是老实人）`, 'inference');
                }
                if (currentId === 'e' && currentStatus === 'honest') {
                    // 戊是老实人：甲和丁都是老实人
                    handleCompoundStatement('e', ['a', 'd'], 'honest');
                }
                if (currentId === 'e' && currentStatus === 'liar') {
                    // 戊是骗子：并非"甲和丁都是老实人"
                    updateTips(`自动推理：戊是骗子，故"甲和丁都是老实人"不成立`, 'inference');
                }
                
                // 2. 单步自动推理：若相关人物未设定角色，自动设定（仅一步）
                if (currentId !== 'd' && currentId !== 'e') {
                    targetPerson.status = expectedStatus;
                    const inferenceMsg = `自动推理：${currentName}是${currentStatus === 'honest' ? '老实人' : '骗子'}，故${targetName}应是${expectedStatus === 'honest' ? '老实人' : '骗子'}（根据陈述："${statement}"）`;
                    updateTips(inferenceMsg, 'inference');
                    // 更新相关人物UI
                    renderPerson(targetPerson);
                    updateConfirmButton(targetId);
                    updateCounter();
                    highlightRelatedPersons(currentId);
                }
            });
        }

        /**
         * 检查与已确认角色的矛盾
         */
        function checkForConflicts(currentId, currentName, currentStatus, statement, targetPerson) {
            const targetName = targetPerson.name;
            let expectedStatus;
            
            if (currentStatus === 'honest') {
                expectedStatus = statement.includes('骗子') ? 'liar' : 'honest';
            } else {
                expectedStatus = statement.includes('骗子') ? 'honest' : 'liar';
            }
            
            if (targetPerson.status !== expectedStatus) {
                // 发现矛盾
                const conflictMsg = `矛盾：${currentName}被确认为${currentStatus === 'honest' ? '老实人' : '骗子'}，其陈述"${statement}"与已确认的${targetName}角色（${targetPerson.status === 'honest' ? '老实人' : '骗子'}）冲突`;
                updateTips(conflictMsg, 'conflict');
                // 高亮冲突人物
                highlightConflicts([currentId, targetPerson.id]);
            }
        }

        /**
         * 处理复合陈述（涉及多个人的陈述）
         */
        function handleCompoundStatement(sourceId, targetIds, expectedStatuses) {
            const sourcePerson = persons.find(p => p.id === sourceId);
            const sourceName = sourcePerson.name;
            
            // 确保参数正确
            if (!Array.isArray(targetIds) || (!Array.isArray(expectedStatuses) && typeof expectedStatuses !== 'string')) {
                return;
            }
            
            // 标准化期望状态为数组
            const statuses = Array.isArray(expectedStatuses) 
                ? expectedStatuses 
                : Array(targetIds.length).fill(expectedStatuses);
            
            targetIds.forEach((targetId, index) => {
                const targetPerson = persons.find(p => p.id === targetId);
                const targetName = targetPerson.name;
                const expectedStatus = statuses[index];
                
                // 如果目标人物已确认，只做矛盾检测
                if (targetPerson.isConfirmed) {
                    if (targetPerson.status !== expectedStatus) {
                        const conflictMsg = `矛盾：${sourceName}被确认为${sourcePerson.status === 'honest' ? '老实人' : '骗子'}，其陈述与已确认的${targetName}角色（${targetPerson.status === 'honest' ? '老实人' : '骗子'}）冲突`;
                        updateTips(conflictMsg, 'conflict');
                        highlightConflicts([sourceId, targetId]);
                    }
                    return;
                }
                
                // 自动设定未确认的目标人物角色
                targetPerson.status = expectedStatus;
                const inferenceMsg = `自动推理：${sourceName}是${sourcePerson.status === 'honest' ? '老实人' : '骗子'}，故${targetName}应是${expectedStatus === 'honest' ? '老实人' : '骗子'}`;
                updateTips(inferenceMsg, 'inference');
                renderPerson(targetPerson);
                updateConfirmButton(targetId);
                updateCounter();
                highlightRelatedPersons(sourceId);
            });
        }

        /**
         * 检查陈述是否为真
         */
        function isStatementTrue(person) {
            const { id, statement } = person;
            
            // 处理不同人物的陈述
            switch(id) {
                case 'a': // 甲：乙是骗子
                    const b = persons.find(p => p.id === 'b');
                    return b.status === 'liar';
                    
                case 'b': // 乙：丙是骗子
                    const c = persons.find(p => p.id === 'c');
                    return c.status === 'liar';
                    
                case 'c': // 丙：戊是骗子
                    const e = persons.find(p => p.id === 'e');
                    return e.status === 'liar';
                    
                case 'd': // 丁：甲和乙都是骗子
                    const a = persons.find(p => p.id === 'a');
                    const b2 = persons.find(p => p.id === 'b');
                    return a.status === 'liar' && b2.status === 'liar';
                    
                case 'e': // 戊：甲和丁都是老实人
                    const a2 = persons.find(p => p.id === 'a');
                    const d = persons.find(p => p.id === 'd');
                    return a2.status === 'honest' && d.status === 'honest';
                    
                default:
                    return false;
            }
        }

        /**
         * 检查结果是否正确
         */
        function checkResult() {
            const resultArea = document.getElementById('resultArea');
            const resultTitle = document.getElementById('resultTitle');
            const resultContent = document.getElementById('resultContent');
            
            // 显示结果区域
            resultArea.classList.remove('hidden');
            
            // 检查数量是否符合要求
            const honestCount = persons.filter(p => p.status === 'honest').length;
            const liarCount = persons.filter(p => p.status === 'liar').length;
            
            if (honestCount !== 2 || liarCount !== 3) {
                resultTitle.textContent = '数量不符合要求';
                resultTitle.className = 'text-xl font-semibold mb-3 text-orange-600';
                resultContent.innerHTML = `题目要求有2个老实人和3个骗子，但当前设置为${honestCount}个老实人和${liarCount}个骗子。`;
                return;
            }
            
            // 检查每个人的陈述是否与其身份一致
            const conflicts = [];
            persons.forEach(person => {
                const statementTrue = isStatementTrue(person);
                
                // 老实人必须说真话，骗子必须说假话
                if (person.status === 'honest' && !statementTrue) {
                    conflicts.push(`${person.name}被设为老实人，但他的陈述是假的`);
                    highlightConflicts([person.id]);
                }
                if (person.status === 'liar' && statementTrue) {
                    conflicts.push(`${person.name}被设为骗子，但他的陈述是真的`);
                    highlightConflicts([person.id]);
                }
            });
            
            // 显示检查结果
            if (conflicts.length === 0) {
                resultTitle.textContent = '恭喜！推理正确！';
                resultTitle.className = 'text-xl font-semibold mb-3 text-honest';
                resultContent.innerHTML = `
                    <p>你的推理符合所有条件：</p>
                    <ul class="list-disc ml-5 mt-2 space-y-1">
                        <li>正好有2个老实人和3个骗子</li>
                        <li>所有老实人的陈述都是真话</li>
                        <li>所有骗子的陈述都是假话</li>
                    </ul>
                    <p class="mt-3">老实人：${persons.filter(p => p.status === 'honest').map(p => p.name).join('、')}</p>
                    <p>骗子：${persons.filter(p => p.status === 'liar').map(p => p.name).join('、')}</p>
                `;
            } else {
                resultTitle.textContent = '推理存在矛盾';
                resultTitle.className = 'text-xl font-semibold mb-3 text-liar';
                resultContent.innerHTML = `
                    <p>发现以下矛盾点：</p>
                    <ul class="list-disc ml-5 mt-2 space-y-1">
                        ${conflicts.map(c => `<li>${c}</li>`).join('')}
                    </ul>
                `;
            }
        }
    </script>
</body>
</html>
